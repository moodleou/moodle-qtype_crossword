<<<<<<< HEAD
{"version":3,"file":"crossword_grid.min.js","sources":["../src/crossword_grid.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * CrosswordGrid class handle every function relative to grid.\n *\n * @module qtype_crossword/crossword_grid\n * @copyright 2022 The Open University\n * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {CrosswordQuestion} from 'qtype_crossword/crossword_question';\nimport {CrosswordClue} from './crossword_clue';\n\nexport class CrosswordGrid extends CrosswordQuestion {\n\n    /**\n     * Constructor.\n     *\n     * @param {Object} options The settings for crossword.\n     */\n    constructor(options) {\n        super(options);\n    }\n\n    /**\n     * Build the background table.\n     */\n    buildBackgroundTable() {\n        let {colsNum, rowsNum, previewSetting} = this.options;\n        let style = previewSetting;\n\n        // Create table element.\n        const tableEl = document.createElement('table');\n\n        // Preview mode will add one more columns and row to add the coordinate helper.\n        colsNum++;\n        rowsNum++;\n\n        tableEl.className = 'crossword-grid';\n        // Set the background color.\n        tableEl.style.backgroundColor = style.backgroundColor;\n\n        for (let i = 0; i < rowsNum; i++) {\n            const rowEl = document.createElement('tr');\n            rowEl.className = 'grid-row';\n            for (let j = 0; j < colsNum; j++) {\n                // Create square.\n                let squareEl = document.createElement('td');\n                squareEl.className = 'grid-square';\n                squareEl.style.borderColor = style.borderColor;\n                squareEl.style.color = style.color;\n\n                if (i === 0 && j === 0) {\n                    squareEl.classList.add('cell-white');\n                }\n\n                // Adding alphanumeric.\n                if (i === 0 && j !== 0) {\n                    squareEl.innerText = this.getColumnLabel(j);\n                    squareEl.classList.add('square-indicate-horizontal');\n                }\n                if (i !== 0 && j === 0) {\n                    squareEl.innerText = i;\n                    squareEl.classList.add('square-indicate-vertical');\n                }\n                rowEl.append(squareEl);\n            }\n            tableEl.append(rowEl);\n        }\n        this.tableEl = tableEl;\n        this.options.crosswordEl.innerHTML = tableEl.outerHTML;\n    }\n\n    /**\n     * Add each cell into table.\n     */\n    addCell() {\n        let {words, previewSetting, rowsNum, colsNum} = this.options;\n        // Don't draw empty words.\n        if (words.length === 0) {\n            return;\n        }\n        for (let i = 0; i < words.length; i++) {\n            let row = words[i].startrow + 1;\n            let column = words[i].startcolumn + 1;\n            let answerLength = words[i].answer.length;\n            let realLength = answerLength + words[i].startcolumn;\n            let allowLength = parseInt(colsNum);\n            let invalidWord = words[i].clue.trim() === '';\n            // Add more columns and row for preview.\n            row++;\n            column++;\n\n            if (!invalidWord) {\n                invalidWord = this.isInvalidAnswer(words[i].answer);\n            }\n\n            if (words[i].orientation) {\n                realLength = answerLength + words[i].startrow;\n                allowLength = parseInt(rowsNum);\n            }\n\n            for (let j = 0; j < words[i].answer.length; j++) {\n                const number = i + 1;\n                const squareEl = document.querySelector('.grid-row:nth-child(' + row + ') .grid-square:nth-child(' + column + ')');\n                if (!squareEl) {\n                    continue;\n                }\n\n                // Paint white background.\n                squareEl.classList.add('background-white');\n\n                if (j === 0) {\n                    const labelEl = squareEl.querySelector('.word-label');\n                    if (!labelEl) {\n                        let spanEl = document.createElement('span');\n                        spanEl.className = 'word-label';\n                        spanEl.innerText = words[i]?.no ?? number;\n                        squareEl.append(spanEl);\n                    } else {\n                        let label = labelEl.innerText;\n                        label += ', ' + words[i]?.no ?? number;\n                        labelEl.innerText = label;\n                    }\n                }\n                const letter = words[i].answer[j].toUpperCase().trim() ?? '';\n                const contentEl = squareEl.querySelector('span.word-content');\n                if (!contentEl) {\n                    let spanEl = document.createElement('span');\n                    spanEl.className = 'word-content';\n                    spanEl.innerText = letter;\n                    squareEl.append(spanEl);\n                } else {\n                    let text = '';\n                    const innerText = contentEl.innerText;\n                    if (innerText.search(letter) < 0) {\n                        text = innerText + ' | ' + letter;\n                        squareEl.style.backgroundColor = previewSetting.conflictColor;\n                        contentEl.innerText = text;\n                    }\n                }\n\n                if (invalidWord || realLength > allowLength) {\n                    squareEl.style.backgroundColor = previewSetting.conflictColor;\n                }\n\n                if (words[i].orientation) {\n                    row++;\n                } else {\n                    column++;\n                }\n            }\n        }\n    }\n\n    /**\n     * Show the crossword preview.\n     */\n    previewCrossword() {\n        // Build the background table.\n        this.buildBackgroundTable();\n        // Fill the cell into the table.\n        this.addCell();\n    }\n\n    /**\n     * Build crossword for attempt.\n     */\n    buildCrossword() {\n        const options = this.options;\n        // Setup size of crossword.\n        this.options = {...options, width: options.colsNum * 32 + 1, height: options.rowsNum * 32 + 1};\n        // Set up for clue input: maxlength, aria-label.\n        const crosswordClue = new CrosswordClue(this.options);\n        crosswordClue.setUpClue();\n        // Draw crossword by SVG to support high contrast mode.\n        this.drawCrosswordSVG();\n        // Sync data between clue section and crossword cell.\n        this.syncDataForInit();\n        // Add event when resized screen.\n        this.addEventResizeScreen();\n    }\n\n    /**\n     * Draw crossword by SVG element.\n     */\n    drawCrosswordSVG() {\n        const options = this.options;\n        const crosswordEl = this.options.crosswordEl;\n\n        if (!crosswordEl) {\n            return;\n        }\n\n        // Create background.\n        let svg = this.createElementNSFrom(\n            'svg',\n            {\n                'class': 'crossword-grid',\n                viewBox: `0 0 ${options.width} ${options.height}`\n            }\n        );\n\n        // Create black background.\n        const rectEl = this.createElementNSFrom(\n            'rect',\n            {\n                'class': 'crossword-grid-background',\n                x: 0,\n                y: 0,\n                width: options.width,\n                height: options.height\n            }\n        );\n        svg.append(rectEl);\n\n        // Create svg body.\n        svg = this.createCrosswordBody(svg);\n\n        // Create an input, by default, it will be hidden.\n        const inputContainEl = this.createElementFrom(\n            'div',\n            {\n                'class': 'crossword-hidden-input-wrapper'\n            }\n        );\n        const inputEl = this.createElementFrom(\n            'input',\n            {\n                type: 'text',\n                'class': 'crossword-hidden-input',\n                maxlength: 1,\n                autocomplete: 'off',\n                spellcheck: false,\n                autocorrect: 'off'\n            }\n        );\n        // Add event for word input.\n        this.addEventForWordInput(inputEl);\n        inputContainEl.append(inputEl);\n        crosswordEl.append(svg, inputContainEl);\n    }\n\n    /**\n     * Creates an element with the specified namespace URI and qualified name.\n     *\n     * @param {String} type\n     * @param {Object} attributes\n     *\n     * @return {Element} The return element.\n     */\n    createElementNSFrom(type, attributes = {}) {\n        const element = document.createElementNS('http://www.w3.org/2000/svg', type);\n        for (let key in attributes) {\n            element.setAttributeNS(null, key, attributes[key]);\n        }\n        return element;\n    }\n\n    /**\n     * Create element with attributes.\n     *\n     * @param {String} type\n     * @param {Object} attributes The attribute list.\n     * @return {Element} The return element.\n     */\n    createElementFrom(type, attributes = {}) {\n        const element = document.createElement(type);\n        for (let key in attributes) {\n            element.setAttribute(key, attributes[key]);\n        }\n        return element;\n    }\n\n    /**\n     * Calculate position and add cell into the crossword.\n     *\n     * @param {Element} svg  The svg element.\n     * @return {Element} The svg element.\n     */\n    createCrosswordBody(svg) {\n        const {words, cellWidth, cellHeight} = this.options;\n        let count = 0;\n        for (let i in words) {\n            const word = words[i];\n            for (let key = 0; key < word.length; key++) {\n                // Prepare attributes for g.\n                const customAttribute = {\n                    'data-startrow': word.startRow,\n                    'data-startcolumn': word.startColumn,\n                    'data-letterindex': key,\n                    'data-word': '(' + word.number + ')',\n                    'data-code': 'A' + count\n                };\n                // Calculate the letter position.\n                const position = this.calculatePosition(word, parseInt(key));\n                // Create rect element with these position.\n                const rectEl = this.createElementNSFrom(\n                    'rect',\n                    {\n                        ...position,\n                        width: cellWidth,\n                        height: cellHeight,\n                        'class': 'crossword-cell'\n                    }\n                );\n                // Create g element with the attributes.\n                let g = this.createElementNSFrom('g', {...customAttribute});\n                // Get exist ting rect element.\n                const existingRectElement = svg.querySelector(`rect.crossword-cell[x='${position.x}'][y='${position.y}']`);\n                // Create text element to hold the letter.\n                const textEl = this.createElementNSFrom(\n                    'text',\n                    {\n                        x: position.x + 11,\n                        y: position.y + 21,\n                        'class': 'crossword-cell-text'\n                    }\n                );\n                // Check if cell is not drawn.\n                if (!existingRectElement) {\n                    // Create cell.\n                    g.append(rectEl);\n                    // If it's the first cell of word.\n                    // Draw word number.\n                    if (parseInt(key) === 0) {\n                        g = this.appendCellNumber(g, position, word.number);\n                    }\n                    g.append(textEl);\n                    // Add event for cell.\n                    this.addEventForG(g);\n                    count++;\n                    svg.append(g);\n                } else {\n                    let existingNumberElement = existingRectElement.closest('g').querySelector('text.crossword-cell-number');\n                    let currentWord = existingRectElement.closest('g').dataset.word;\n                    let g;\n                    existingRectElement.closest('g').dataset.word = currentWord + '(' + word.number + ')';\n                    if (parseInt(key) !== 0) {\n                        continue;\n                    }\n                    if (existingNumberElement) {\n                        // Append word number, if this cell is existed another one.\n                        existingNumberElement.append(', ' + word.number);\n                    } else {\n                        // Create new word number.\n                        g = existingRectElement.closest('g');\n                        this.appendCellNumber(g, position, word.number);\n                    }\n                }\n            }\n        }\n        return svg;\n    }\n\n    /**\n     * Create word number for the cell.\n     *\n     * @param {Element} g The g element.\n     * @param {Object} position The coordinates of letter.\n     * @param {Number} wordNumber The word number.\n     *\n     * @return {Element} The g element.\n     */\n    appendCellNumber(g, position, wordNumber) {\n        // Update position.\n        const x = position.x + 1;\n        const y = position.y + 9;\n        let textNumber = this.createElementNSFrom(\n            'text',\n            {\n                x,\n                y,\n                'class': 'crossword-cell-number'\n            }\n        );\n        textNumber.append(wordNumber);\n        g.append(textNumber);\n        return g;\n    }\n\n    /**\n     * Add event to the g element.\n     *\n     * @param {Element} g The g element.\n     */\n    addEventForG(g) {\n        const {readonly} = this.options;\n        if (readonly) {\n            return;\n        }\n        // Handle event click.\n        g.addEventListener('click', (e) => {\n            const inputWrapperEl = this.options.crosswordEl.querySelector('.crossword-hidden-input-wrapper');\n            const inputEl = inputWrapperEl.querySelector('input');\n            let element = e.target;\n            // Make sure select g.\n            if (element.tagName !== 'g') {\n                element = element.closest('g');\n            }\n            this.handleWordSelect(element);\n            inputEl.dataset.code = element.dataset.code;\n            inputEl.value = '';\n            this.updatePositionForCellInput(element.querySelector('rect'));\n            inputEl.focus();\n        });\n    }\n\n    /**\n     * Handle action when click on cell.\n     *\n     * @param {Element} gEl The g element.\n     */\n    handleWordSelect(gEl) {\n        const currentCell = gEl.dataset.code;\n        let words = gEl.dataset.word;\n        let focus = -1;\n        let {coordinates, wordNumber} = this.options;\n\n        // Detect word number.\n        words = words.match(/(\\d+)/g);\n\n        // Detect word number based on event click.\n        // The focus variable is the new word number.\n        if (currentCell === coordinates) {\n            const indexCell = words.indexOf(wordNumber);\n            if (words[indexCell + 1] !== undefined) {\n                focus = words[indexCell + 1];\n            } else {\n                focus = words[0];\n            }\n        } else {\n            // Update new coordinates.\n            this.options.coordinates = currentCell;\n            if (wordNumber < 0) {\n                this.options.wordNumber = words[0];\n            }\n            if (words.includes(wordNumber)) {\n                focus = wordNumber;\n            } else {\n                focus = words[0];\n            }\n        }\n        // Update word number.\n        this.options.wordNumber = focus;\n        const word = this.options.words.find(o => o.number === parseInt(focus));\n        if (!word) {\n            return;\n        }\n        // Sorting and Updating letter index.\n        this.updateLetterIndexForCells(word);\n        // Toggle highlight and focused.\n        this.toggleHighlight(word, gEl);\n        // Focus the clue.\n        this.focusClue();\n        // Update sticky clue for mobile version.\n        this.setStickyClue();\n    }\n\n    /**\n     * Set size and position for cell input.\n     *\n     * @param {Element} [rectEl=null] Rect element.\n     */\n    updatePositionForCellInput(rectEl = null) {\n        if (rectEl === null) {\n            rectEl = this.options.crosswordEl.querySelector('rect.crossword-cell-focussed');\n        }\n        if (rectEl) {\n            const rect = rectEl.getBoundingClientRect();\n            const parentEl = this.options.crosswordEl.querySelector('.crossword-grid').getBoundingClientRect();\n            const inputWrapperEl = this.options.crosswordEl.querySelector('.crossword-hidden-input-wrapper');\n            let top = rect.top - parentEl.top;\n            if (top < 1) {\n                top = 1;\n            }\n            inputWrapperEl.style.cssText = `\n                display: block; top: ${top}px;\n                left: ${rect.left - parentEl.left}px;\n                width: ${rect.width}px;\n                height: ${rect.height}px\n            `;\n        }\n    }\n\n    /**\n     * Add event to word input element.\n     *\n     * @param {Element} inputEl The input element.\n     */\n    addEventForWordInput(inputEl) {\n        const {readonly} = this.options;\n        if (readonly) {\n            return;\n        }\n        inputEl.addEventListener('keypress', (e) => {\n            e.preventDefault();\n            const {wordNumber} = this.options;\n            const inputEl = e.target;\n            const code = inputEl.dataset.code;\n            let value = e.key.toUpperCase();\n            if (this.replaceText(e.key) === '') {\n                return false;\n            }\n            // Filter value.\n            if (code) {\n                const textEl = this.options.crosswordEl.querySelector(`g[data-code='${code}'] text.crossword-cell-text`);\n                if (!textEl) {\n                    return false;\n                }\n                textEl.innerHTML = value;\n                const letterIndex = parseInt(textEl.closest('g').dataset.letterindex);\n                const nextCellEl = this.options.crosswordEl.querySelector(\n                    `g[data-word*='(${wordNumber})'][data-letterindex='${letterIndex + 1}']`\n                );\n                // Interact with clue.\n                this.bindDataToClueInput(textEl.closest('g'), e.key);\n                if (nextCellEl) {\n                    nextCellEl.dispatchEvent(new Event('click'));\n                }\n            }\n            return true;\n        });\n\n        inputEl.addEventListener('keyup', (event) => {\n            event.preventDefault();\n            const {wordNumber, cellWidth, cellHeight} = this.options;\n            const {key, target} = event;\n            const code = target.dataset.code;\n            const gEl = this.options.crosswordEl.querySelector(`g[data-code='${code}']`);\n            const letterIndex = parseInt(gEl.dataset.letterindex);\n            const previousCell = this.options.crosswordEl.querySelector(\n                `g[data-word*='(${wordNumber})'][data-letterindex='${letterIndex - 1}']`\n            );\n            const textEl = gEl.querySelector('text.crossword-cell-text');\n            let x = parseInt(gEl.querySelector('rect').getAttributeNS(null, 'x'));\n            let y = parseInt(gEl.querySelector('rect').getAttributeNS(null, 'y'));\n            if (key === this.DELETE || key === this.BACKSPACE) {\n                if (textEl.innerHTML === '') {\n                    if (previousCell) {\n                        previousCell.dispatchEvent(new Event('click'));\n                    }\n                } else {\n                    textEl.innerHTML = '';\n                    this.bindDataToClueInput(gEl, '_');\n                }\n            }\n            if ([this.ARROW_UP, this.ARROW_DOWN, this.ARROW_LEFT, this.ARROW_RIGHT].includes(key)) {\n                if (key === this.ARROW_UP) {\n                    y -= (cellHeight + 1);\n                }\n                if (key === this.ARROW_DOWN) {\n                    y += (cellHeight + 1);\n                }\n                if (key === this.ARROW_LEFT) {\n                    x -= (cellWidth + 1);\n                }\n                if (key === this.ARROW_RIGHT) {\n                    x += (cellWidth + 1);\n                }\n                const nextCell = this.options.crosswordEl.querySelector(`g rect[x='${x}'][y='${y}']`);\n                if (nextCell) {\n                    nextCell.closest('g').dispatchEvent(new Event('click'));\n                }\n            }\n        });\n\n        inputEl.addEventListener('click', (e) => {\n            const inputEl = e.target;\n            const code = inputEl.dataset.code;\n            const gEl = this.options.crosswordEl.querySelector(`g[data-code='${code}']`);\n            this.handleWordSelect(gEl);\n        });\n\n        inputEl.addEventListener('keydown', (e) => {\n            let {key} = e;\n            key = key.toLowerCase();\n            if (e.ctrlKey) {\n                if (\n                    key === this.Z_KEY ||\n                    key === this.A_KEY\n                ) {\n                    e.preventDefault();\n                }\n            }\n\n            if (e.key === this.ENTER) {\n                e.preventDefault();\n            }\n        });\n\n        inputEl.addEventListener('paste', (e) => {\n            e.preventDefault();\n        });\n    }\n\n    /**\n     * Add event to resize the screen width.\n     */\n    addEventResizeScreen() {\n        window.addEventListener('resize', () => {\n            this.updatePositionForCellInput();\n        });\n    }\n}\n"],"names":["CrosswordGrid","CrosswordQuestion","constructor","options","buildBackgroundTable","colsNum","rowsNum","previewSetting","this","style","tableEl","document","createElement","className","backgroundColor","i","rowEl","j","squareEl","borderColor","color","classList","add","innerText","getColumnLabel","append","crosswordEl","innerHTML","outerHTML","addCell","words","length","row","startrow","column","startcolumn","answerLength","answer","realLength","allowLength","parseInt","invalidWord","clue","trim","isInvalidAnswer","orientation","number","querySelector","labelEl","label","_words$i2","no","spanEl","_words$i","letter","toUpperCase","contentEl","text","search","conflictColor","previewCrossword","buildCrossword","width","height","CrosswordClue","setUpClue","drawCrosswordSVG","syncDataForInit","addEventResizeScreen","svg","createElementNSFrom","viewBox","rectEl","x","y","createCrosswordBody","inputContainEl","createElementFrom","inputEl","type","maxlength","autocomplete","spellcheck","autocorrect","addEventForWordInput","attributes","element","createElementNS","key","setAttributeNS","setAttribute","cellWidth","cellHeight","count","word","customAttribute","startRow","startColumn","position","calculatePosition","g","existingRectElement","textEl","existingNumberElement","closest","currentWord","dataset","appendCellNumber","addEventForG","wordNumber","textNumber","readonly","addEventListener","e","target","tagName","handleWordSelect","code","value","updatePositionForCellInput","focus","gEl","currentCell","coordinates","match","indexCell","indexOf","undefined","includes","find","o","updateLetterIndexForCells","toggleHighlight","focusClue","setStickyClue","rect","getBoundingClientRect","parentEl","inputWrapperEl","top","cssText","left","preventDefault","replaceText","letterIndex","letterindex","nextCellEl","bindDataToClueInput","dispatchEvent","Event","event","previousCell","getAttributeNS","DELETE","BACKSPACE","ARROW_UP","ARROW_DOWN","ARROW_LEFT","ARROW_RIGHT","nextCell","toLowerCase","ctrlKey","Z_KEY","A_KEY","ENTER","window"],"mappings":";;;;;;;;MA0BaA,sBAAsBC,sCAO/BC,YAAYC,eACFA,SAMVC,2BACQC,QAACA,QAADC,QAAUA,QAAVC,eAAmBA,gBAAkBC,KAAKL,QAC1CM,MAAQF,qBAGNG,QAAUC,SAASC,cAAc,SAGvCP,UACAC,UAEAI,QAAQG,UAAY,iBAEpBH,QAAQD,MAAMK,gBAAkBL,MAAMK,oBAEjC,IAAIC,EAAI,EAAGA,EAAIT,QAASS,IAAK,OACxBC,MAAQL,SAASC,cAAc,MACrCI,MAAMH,UAAY,eACb,IAAII,EAAI,EAAGA,EAAIZ,QAASY,IAAK,KAE1BC,SAAWP,SAASC,cAAc,MACtCM,SAASL,UAAY,cACrBK,SAAST,MAAMU,YAAcV,MAAMU,YACnCD,SAAST,MAAMW,MAAQX,MAAMW,MAEnB,IAANL,GAAiB,IAANE,GACXC,SAASG,UAAUC,IAAI,cAIjB,IAANP,GAAiB,IAANE,IACXC,SAASK,UAAYf,KAAKgB,eAAeP,GACzCC,SAASG,UAAUC,IAAI,+BAEjB,IAANP,GAAiB,IAANE,IACXC,SAASK,UAAYR,EACrBG,SAASG,UAAUC,IAAI,6BAE3BN,MAAMS,OAAOP,UAEjBR,QAAQe,OAAOT,YAEdN,QAAUA,aACVP,QAAQuB,YAAYC,UAAYjB,QAAQkB,UAMjDC,cACQC,MAACA,MAADvB,eAAQA,eAARD,QAAwBA,QAAxBD,QAAiCA,SAAWG,KAAKL,WAEhC,IAAjB2B,MAAMC,WAGL,IAAIhB,EAAI,EAAGA,EAAIe,MAAMC,OAAQhB,IAAK,KAC/BiB,IAAMF,MAAMf,GAAGkB,SAAW,EAC1BC,OAASJ,MAAMf,GAAGoB,YAAc,EAChCC,aAAeN,MAAMf,GAAGsB,OAAON,OAC/BO,WAAaF,aAAeN,MAAMf,GAAGoB,YACrCI,YAAcC,SAASnC,SACvBoC,YAAuC,KAAzBX,MAAMf,GAAG2B,KAAKC,OAEhCX,MACAE,SAEKO,cACDA,YAAcjC,KAAKoC,gBAAgBd,MAAMf,GAAGsB,SAG5CP,MAAMf,GAAG8B,cACTP,WAAaF,aAAeN,MAAMf,GAAGkB,SACrCM,YAAcC,SAASlC,cAGtB,IAAIW,EAAI,EAAGA,EAAIa,MAAMf,GAAGsB,OAAON,OAAQd,IAAK,iCACvC6B,OAAS/B,EAAI,EACbG,SAAWP,SAASoC,cAAc,uBAAyBf,IAAM,4BAA8BE,OAAS,SACzGhB,qBAKLA,SAASG,UAAUC,IAAI,oBAEb,IAANL,EAAS,OACH+B,QAAU9B,SAAS6B,cAAc,kBAClCC,QAKE,wBACCC,MAAQD,QAAQzB,UACpB0B,oBAAS,wBAAOnB,MAAMf,+BAANmC,UAAUC,yBAAML,OAChCE,QAAQzB,UAAY0B,UARV,8BACNG,OAASzC,SAASC,cAAc,QACpCwC,OAAOvC,UAAY,aACnBuC,OAAO7B,+CAAYO,MAAMf,8BAANsC,SAAUF,sCAAML,OACnC5B,SAASO,OAAO2B,eAOlBE,qCAASxB,MAAMf,GAAGsB,OAAOpB,GAAGsC,cAAcZ,8DAAU,GACpDa,UAAYtC,SAAS6B,cAAc,wBACpCS,UAKE,KACCC,KAAO,SACLlC,UAAYiC,UAAUjC,UACxBA,UAAUmC,OAAOJ,QAAU,IAC3BG,KAAOlC,UAAY,MAAQ+B,OAC3BpC,SAAST,MAAMK,gBAAkBP,eAAeoD,cAChDH,UAAUjC,UAAYkC,UAXd,KACRL,OAASzC,SAASC,cAAc,QACpCwC,OAAOvC,UAAY,eACnBuC,OAAO7B,UAAY+B,OACnBpC,SAASO,OAAO2B,SAWhBX,aAAeH,WAAaC,eAC5BrB,SAAST,MAAMK,gBAAkBP,eAAeoD,eAGhD7B,MAAMf,GAAG8B,YACTb,MAEAE,WAShB0B,wBAESxD,4BAEAyB,UAMTgC,uBACU1D,QAAUK,KAAKL,aAEhBA,QAAU,IAAIA,QAAS2D,MAAyB,GAAlB3D,QAAQE,QAAe,EAAG0D,OAA0B,GAAlB5D,QAAQG,QAAe,GAEtE,IAAI0D,8BAAcxD,KAAKL,SAC/B8D,iBAETC,wBAEAC,uBAEAC,uBAMTF,yBACU/D,QAAUK,KAAKL,QACfuB,YAAclB,KAAKL,QAAQuB,gBAE5BA,uBAKD2C,IAAM7D,KAAK8D,oBACX,MACA,OACa,iBACTC,sBAAgBpE,QAAQ2D,kBAAS3D,QAAQ4D,gBAK3CS,OAAShE,KAAK8D,oBAChB,OACA,OACa,4BACTG,EAAG,EACHC,EAAG,EACHZ,MAAO3D,QAAQ2D,MACfC,OAAQ5D,QAAQ4D,SAGxBM,IAAI5C,OAAO+C,QAGXH,IAAM7D,KAAKmE,oBAAoBN,WAGzBO,eAAiBpE,KAAKqE,kBACxB,MACA,OACa,mCAGXC,QAAUtE,KAAKqE,kBACjB,QACA,CACIE,KAAM,aACG,yBACTC,UAAW,EACXC,aAAc,MACdC,YAAY,EACZC,YAAa,aAIhBC,qBAAqBN,SAC1BF,eAAenD,OAAOqD,SACtBpD,YAAYD,OAAO4C,IAAKO,gBAW5BN,oBAAoBS,UAAMM,kEAAa,SAC7BC,QAAU3E,SAAS4E,gBAAgB,6BAA8BR,UAClE,IAAIS,OAAOH,WACZC,QAAQG,eAAe,KAAMD,IAAKH,WAAWG,aAE1CF,QAUXT,kBAAkBE,UAAMM,kEAAa,SAC3BC,QAAU3E,SAASC,cAAcmE,UAClC,IAAIS,OAAOH,WACZC,QAAQI,aAAaF,IAAKH,WAAWG,aAElCF,QASXX,oBAAoBN,WACVvC,MAACA,MAAD6D,UAAQA,UAARC,WAAmBA,YAAcpF,KAAKL,YACxC0F,MAAQ,MACP,IAAI9E,KAAKe,MAAO,OACXgE,KAAOhE,MAAMf,OACd,IAAIyE,IAAM,EAAGA,IAAMM,KAAK/D,OAAQyD,MAAO,OAElCO,gBAAkB,iBACHD,KAAKE,4BACFF,KAAKG,+BACLT,gBACP,IAAMM,KAAKhD,OAAS,gBACpB,IAAM+C,OAGjBK,SAAW1F,KAAK2F,kBAAkBL,KAAMtD,SAASgD,MAEjDhB,OAAShE,KAAK8D,oBAChB,OACA,IACO4B,SACHpC,MAAO6B,UACP5B,OAAQ6B,iBACC,uBAIbQ,EAAI5F,KAAK8D,oBAAoB,IAAK,IAAIyB,wBAEpCM,oBAAsBhC,IAAItB,+CAAwCmD,SAASzB,mBAAUyB,SAASxB,SAE9F4B,OAAS9F,KAAK8D,oBAChB,OACA,CACIG,EAAGyB,SAASzB,EAAI,GAChBC,EAAGwB,SAASxB,EAAI,SACP,2BAIZ2B,oBAaE,KAGCD,EAFAG,sBAAwBF,oBAAoBG,QAAQ,KAAKzD,cAAc,8BACvE0D,YAAcJ,oBAAoBG,QAAQ,KAAKE,QAAQZ,QAE3DO,oBAAoBG,QAAQ,KAAKE,QAAQZ,KAAOW,YAAc,IAAMX,KAAKhD,OAAS,IAC5D,IAAlBN,SAASgD,cAGTe,sBAEAA,sBAAsB9E,OAAO,KAAOqE,KAAKhD,SAGzCsD,EAAIC,oBAAoBG,QAAQ,UAC3BG,iBAAiBP,EAAGF,SAAUJ,KAAKhD,cAzB5CsD,EAAE3E,OAAO+C,QAGa,IAAlBhC,SAASgD,OACTY,EAAI5F,KAAKmG,iBAAiBP,EAAGF,SAAUJ,KAAKhD,SAEhDsD,EAAE3E,OAAO6E,aAEJM,aAAaR,GAClBP,QACAxB,IAAI5C,OAAO2E,WAoBhB/B,IAYXsC,iBAAiBP,EAAGF,SAAUW,kBAEpBpC,EAAIyB,SAASzB,EAAI,EACjBC,EAAIwB,SAASxB,EAAI,MACnBoC,WAAatG,KAAK8D,oBAClB,OACA,CACIG,EAAAA,EACAC,EAAAA,QACS,iCAGjBoC,WAAWrF,OAAOoF,YAClBT,EAAE3E,OAAOqF,YACFV,EAQXQ,aAAaR,SACHW,SAACA,UAAYvG,KAAKL,QACpB4G,UAIJX,EAAEY,iBAAiB,SAAUC,UAEnBnC,QADiBtE,KAAKL,QAAQuB,YAAYqB,cAAc,mCAC/BA,cAAc,aACzCuC,QAAU2B,EAAEC,OAEQ,MAApB5B,QAAQ6B,UACR7B,QAAUA,QAAQkB,QAAQ,WAEzBY,iBAAiB9B,SACtBR,QAAQ4B,QAAQW,KAAO/B,QAAQoB,QAAQW,KACvCvC,QAAQwC,MAAQ,QACXC,2BAA2BjC,QAAQvC,cAAc,SACtD+B,QAAQ0C,WAShBJ,iBAAiBK,WACPC,YAAcD,IAAIf,QAAQW,SAC5BvF,MAAQ2F,IAAIf,QAAQZ,KACpB0B,OAAS,GACTG,YAACA,YAADd,WAAcA,YAAcrG,KAAKL,WAGrC2B,MAAQA,MAAM8F,MAAM,UAIhBF,cAAgBC,YAAa,OACvBE,UAAY/F,MAAMgG,QAAQjB,YAE5BW,WADyBO,IAAzBjG,MAAM+F,UAAY,GACV/F,MAAM+F,UAAY,GAElB/F,MAAM,aAIb3B,QAAQwH,YAAcD,YACvBb,WAAa,SACR1G,QAAQ0G,WAAa/E,MAAM,IAGhC0F,MADA1F,MAAMkG,SAASnB,YACPA,WAEA/E,MAAM,QAIjB3B,QAAQ0G,WAAaW,YACpB1B,KAAOtF,KAAKL,QAAQ2B,MAAMmG,MAAKC,GAAKA,EAAEpF,SAAWN,SAASgF,SAC3D1B,YAIAqC,0BAA0BrC,WAE1BsC,gBAAgBtC,KAAM2B,UAEtBY,iBAEAC,iBAQTf,iCAA2B/C,8DAAS,QACjB,OAAXA,SACAA,OAAShE,KAAKL,QAAQuB,YAAYqB,cAAc,iCAEhDyB,OAAQ,OACF+D,KAAO/D,OAAOgE,wBACdC,SAAWjI,KAAKL,QAAQuB,YAAYqB,cAAc,mBAAmByF,wBACrEE,eAAiBlI,KAAKL,QAAQuB,YAAYqB,cAAc,uCAC1D4F,IAAMJ,KAAKI,IAAMF,SAASE,IAC1BA,IAAM,IACNA,IAAM,GAEVD,eAAejI,MAAMmI,yDACMD,0CACfJ,KAAKM,KAAOJ,SAASI,4CACpBN,KAAKzE,8CACJyE,KAAKxE,4BAU3BqB,qBAAqBN,eACXiC,SAACA,UAAYvG,KAAKL,QACpB4G,WAGJjC,QAAQkC,iBAAiB,YAAaC,IAClCA,EAAE6B,uBACIjC,WAACA,YAAcrG,KAAKL,QAEpBkH,KADUJ,EAAEC,OACGR,QAAQW,SACzBC,MAAQL,EAAEzB,IAAIjC,iBACc,KAA5B/C,KAAKuI,YAAY9B,EAAEzB,YACZ,KAGP6B,KAAM,OACAf,OAAS9F,KAAKL,QAAQuB,YAAYqB,qCAA8BsE,yCACjEf,cACM,EAEXA,OAAO3E,UAAY2F,YACb0B,YAAcxG,SAAS8D,OAAOE,QAAQ,KAAKE,QAAQuC,aACnDC,WAAa1I,KAAKL,QAAQuB,YAAYqB,uCACtB8D,4CAAmCmC,YAAc,cAGlEG,oBAAoB7C,OAAOE,QAAQ,KAAMS,EAAEzB,KAC5C0D,YACAA,WAAWE,cAAc,IAAIC,MAAM,iBAGpC,KAGXvE,QAAQkC,iBAAiB,SAAUsC,QAC/BA,MAAMR,uBACAjC,WAACA,WAADlB,UAAaA,UAAbC,WAAwBA,YAAcpF,KAAKL,SAC3CqF,IAACA,IAAD0B,OAAMA,QAAUoC,MAChBjC,KAAOH,OAAOR,QAAQW,KACtBI,IAAMjH,KAAKL,QAAQuB,YAAYqB,qCAA8BsE,YAC7D2B,YAAcxG,SAASiF,IAAIf,QAAQuC,aACnCM,aAAe/I,KAAKL,QAAQuB,YAAYqB,uCACxB8D,4CAAmCmC,YAAc,SAEjE1C,OAASmB,IAAI1E,cAAc,gCAC7B0B,EAAIjC,SAASiF,IAAI1E,cAAc,QAAQyG,eAAe,KAAM,MAC5D9E,EAAIlC,SAASiF,IAAI1E,cAAc,QAAQyG,eAAe,KAAM,SAC5DhE,MAAQhF,KAAKiJ,QAAUjE,MAAQhF,KAAKkJ,YACX,KAArBpD,OAAO3E,UACH4H,cACAA,aAAaH,cAAc,IAAIC,MAAM,WAGzC/C,OAAO3E,UAAY,QACdwH,oBAAoB1B,IAAK,OAGlC,CAACjH,KAAKmJ,SAAUnJ,KAAKoJ,WAAYpJ,KAAKqJ,WAAYrJ,KAAKsJ,aAAa9B,SAASxC,KAAM,CAC/EA,MAAQhF,KAAKmJ,WACbjF,GAAMkB,WAAa,GAEnBJ,MAAQhF,KAAKoJ,aACblF,GAAMkB,WAAa,GAEnBJ,MAAQhF,KAAKqJ,aACbpF,GAAMkB,UAAY,GAElBH,MAAQhF,KAAKsJ,cACbrF,GAAMkB,UAAY,SAEhBoE,SAAWvJ,KAAKL,QAAQuB,YAAYqB,kCAA2B0B,mBAAUC,SAC3EqF,UACAA,SAASvD,QAAQ,KAAK4C,cAAc,IAAIC,MAAM,cAK1DvE,QAAQkC,iBAAiB,SAAUC,UAEzBI,KADUJ,EAAEC,OACGR,QAAQW,KACvBI,IAAMjH,KAAKL,QAAQuB,YAAYqB,qCAA8BsE,iBAC9DD,iBAAiBK,QAG1B3C,QAAQkC,iBAAiB,WAAYC,QAC7BzB,IAACA,KAAOyB,EACZzB,IAAMA,IAAIwE,cACN/C,EAAEgD,UAEEzE,MAAQhF,KAAK0J,OACb1E,MAAQhF,KAAK2J,OAEblD,EAAE6B,kBAIN7B,EAAEzB,MAAQhF,KAAK4J,OACfnD,EAAE6B,oBAIVhE,QAAQkC,iBAAiB,SAAUC,IAC/BA,EAAE6B,qBAOV1E,uBACIiG,OAAOrD,iBAAiB,UAAU,UACzBO"}
=======
{"version":3,"file":"crossword_grid.min.js","sources":["../src/crossword_grid.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * CrosswordGrid class handle every function relative to grid.\r\n *\r\n * @module qtype_crossword/crossword_grid\r\n * @copyright 2022 The Open University\r\n * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\nimport {CrosswordQuestion} from 'qtype_crossword/crossword_question';\r\nimport {CrosswordClue} from './crossword_clue';\r\n\r\nexport class CrosswordGrid extends CrosswordQuestion {\r\n\r\n    /**\r\n     * Constructor.\r\n     *\r\n     * @param {Object} options The settings for crossword.\r\n     */\r\n    constructor(options) {\r\n        super(options);\r\n    }\r\n\r\n    /**\r\n     * Build the background table.\r\n     */\r\n    buildBackgroundTable() {\r\n        let {colsNum, rowsNum, previewSetting} = this.options;\r\n        let style = previewSetting;\r\n\r\n        // Create table element.\r\n        const tableEl = document.createElement('table');\r\n\r\n        // Preview mode will add one more columns and row to add the coordinate helper.\r\n        colsNum++;\r\n        rowsNum++;\r\n\r\n        tableEl.className = 'crossword-grid';\r\n        // Set the background color.\r\n        tableEl.style.backgroundColor = style.backgroundColor;\r\n\r\n        for (let i = 0; i < rowsNum; i++) {\r\n            const rowEl = document.createElement('tr');\r\n            rowEl.className = 'grid-row';\r\n            for (let j = 0; j < colsNum; j++) {\r\n                // Create square.\r\n                let squareEl = document.createElement('td');\r\n                squareEl.className = 'grid-square';\r\n                squareEl.style.borderColor = style.borderColor;\r\n                squareEl.style.color = style.color;\r\n\r\n                if (i === 0 && j === 0) {\r\n                    squareEl.classList.add('cell-white');\r\n                }\r\n\r\n                // Adding alphanumeric.\r\n                if (i === 0 && j !== 0) {\r\n                    squareEl.innerText = this.getColumnLabel(j);\r\n                    squareEl.classList.add('square-indicate-horizontal');\r\n                }\r\n                if (i !== 0 && j === 0) {\r\n                    squareEl.innerText = i;\r\n                    squareEl.classList.add('square-indicate-vertical');\r\n                }\r\n                rowEl.append(squareEl);\r\n            }\r\n            tableEl.append(rowEl);\r\n        }\r\n        this.tableEl = tableEl;\r\n        this.options.crosswordEl.innerHTML = tableEl.outerHTML;\r\n    }\r\n\r\n    /**\r\n     * Add each cell into table.\r\n     */\r\n    addCell() {\r\n        let {words, previewSetting, rowsNum, colsNum} = this.options;\r\n        // Don't draw empty words.\r\n        if (words.length === 0) {\r\n            return;\r\n        }\r\n        for (let i = 0; i < words.length; i++) {\r\n            let row = words[i].startrow + 1;\r\n            let column = words[i].startcolumn + 1;\r\n            let answerLength = words[i].answer.length;\r\n            let realLength = answerLength + words[i].startcolumn;\r\n            let allowLength = parseInt(colsNum);\r\n            let invalidWord = words[i].clue.trim() === '';\r\n            // Add more columns and row for preview.\r\n            row++;\r\n            column++;\r\n\r\n            if (!invalidWord) {\r\n                invalidWord = this.isInvalidAnswer(words[i].answer);\r\n            }\r\n\r\n            if (words[i].orientation) {\r\n                realLength = answerLength + words[i].startrow;\r\n                allowLength = parseInt(rowsNum);\r\n            }\r\n\r\n            for (let j = 0; j < words[i].answer.length; j++) {\r\n                const number = i + 1;\r\n                const squareEl = document.querySelector('.grid-row:nth-child(' + row + ') .grid-square:nth-child(' + column + ')');\r\n                if (!squareEl) {\r\n                    continue;\r\n                }\r\n\r\n                // Paint white background.\r\n                squareEl.classList.add('background-white');\r\n\r\n                if (j === 0) {\r\n                    const labelEl = squareEl.querySelector('.word-label');\r\n                    if (!labelEl) {\r\n                        let spanEl = document.createElement('span');\r\n                        spanEl.className = 'word-label';\r\n                        spanEl.innerText = words[i]?.no ?? number;\r\n                        squareEl.append(spanEl);\r\n                    } else {\r\n                        let label = labelEl.innerText;\r\n                        label += ', ' + words[i]?.no ?? number;\r\n                        labelEl.innerText = label;\r\n                    }\r\n                }\r\n                const letter = words[i].answer[j].toUpperCase().trim() ?? '';\r\n                const contentEl = squareEl.querySelector('span.word-content');\r\n                if (!contentEl) {\r\n                    let spanEl = document.createElement('span');\r\n                    spanEl.className = 'word-content';\r\n                    spanEl.innerText = letter;\r\n                    squareEl.append(spanEl);\r\n                } else {\r\n                    let text = '';\r\n                    const innerText = contentEl.innerText;\r\n                    if (innerText.search(letter) < 0) {\r\n                        text = innerText + ' | ' + letter;\r\n                        squareEl.style.backgroundColor = previewSetting.conflictColor;\r\n                        contentEl.innerText = text;\r\n                    }\r\n                }\r\n\r\n                if (invalidWord || realLength > allowLength) {\r\n                    squareEl.style.backgroundColor = previewSetting.conflictColor;\r\n                }\r\n\r\n                if (words[i].orientation) {\r\n                    row++;\r\n                } else {\r\n                    column++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Show the crossword preview.\r\n     */\r\n    previewCrossword() {\r\n        // Build the background table.\r\n        this.buildBackgroundTable();\r\n        // Fill the cell into the table.\r\n        this.addCell();\r\n    }\r\n\r\n    /**\r\n     * Build crossword for attempt.\r\n     */\r\n    buildCrossword() {\r\n        const options = this.options;\r\n        // Setup size of crossword.\r\n        this.options = {...options, width: options.colsNum * 32 + 1, height: options.rowsNum * 32 + 1};\r\n        // Set up for clue input: maxlength, aria-label.\r\n        const crosswordClue = new CrosswordClue(this.options);\r\n        crosswordClue.setUpClue();\r\n        // Draw crossword by SVG to support high contrast mode.\r\n        this.drawCrosswordSVG();\r\n        // Sync data between clue section and crossword cell.\r\n        this.syncDataForInit();\r\n        // Add event when resized screen.\r\n        this.addEventResizeScreen();\r\n    }\r\n\r\n    /**\r\n     * Draw crossword by SVG element.\r\n     */\r\n    drawCrosswordSVG() {\r\n        const options = this.options;\r\n        const crosswordEl = this.options.crosswordEl;\r\n\r\n        if (!crosswordEl) {\r\n            return;\r\n        }\r\n\r\n        // Create background.\r\n        let svg = this.createElementNSFrom(\r\n            'svg',\r\n            {\r\n                'class': 'crossword-grid',\r\n                viewBox: `0 0 ${options.width} ${options.height}`\r\n            }\r\n        );\r\n\r\n        // Create black background.\r\n        const rectEl = this.createElementNSFrom(\r\n            'rect',\r\n            {\r\n                'class': 'crossword-grid-background',\r\n                x: 0,\r\n                y: 0,\r\n                width: options.width,\r\n                height: options.height\r\n            }\r\n        );\r\n        svg.append(rectEl);\r\n\r\n        // Create svg body.\r\n        svg = this.createCrosswordBody(svg);\r\n\r\n        // Create an input, by default, it will be hidden.\r\n        const inputContainEl = this.createElementFrom(\r\n            'div',\r\n            {\r\n                'class': 'crossword-hidden-input-wrapper'\r\n            }\r\n        );\r\n        const inputEl = this.createElementFrom(\r\n            'input',\r\n            {\r\n                type: 'text',\r\n                'class': 'crossword-hidden-input',\r\n                maxlength: 1,\r\n                autocomplete: 'off',\r\n                spellcheck: false,\r\n                autocorrect: 'off'\r\n            }\r\n        );\r\n        // Add event for word input.\r\n        this.addEventForWordInput(inputEl);\r\n        inputContainEl.append(inputEl);\r\n        crosswordEl.append(svg, inputContainEl);\r\n    }\r\n\r\n    /**\r\n     * Creates an element with the specified namespace URI and qualified name.\r\n     *\r\n     * @param {String} type\r\n     * @param {Object} attributes\r\n     *\r\n     * @return {Element} The return element.\r\n     */\r\n    createElementNSFrom(type, attributes = {}) {\r\n        const element = document.createElementNS('http://www.w3.org/2000/svg', type);\r\n        for (let key in attributes) {\r\n            element.setAttributeNS(null, key, attributes[key]);\r\n        }\r\n        return element;\r\n    }\r\n\r\n    /**\r\n     * Create element with attributes.\r\n     *\r\n     * @param {String} type\r\n     * @param {Object} attributes The attribute list.\r\n     * @return {Element} The return element.\r\n     */\r\n    createElementFrom(type, attributes = {}) {\r\n        const element = document.createElement(type);\r\n        for (let key in attributes) {\r\n            element.setAttribute(key, attributes[key]);\r\n        }\r\n        return element;\r\n    }\r\n\r\n    /**\r\n     * Calculate position and add cell into the crossword.\r\n     *\r\n     * @param {Element} svg  The svg element.\r\n     * @return {Element} The svg element.\r\n     */\r\n    createCrosswordBody(svg) {\r\n        const {words, cellWidth, cellHeight} = this.options;\r\n        let count = 0;\r\n        for (let i in words) {\r\n            const word = words[i];\r\n            for (let key = 0; key < word.length; key++) {\r\n                // Prepare attributes for g.\r\n                const customAttribute = {\r\n                    startRow: word.startRow,\r\n                    startColumn: word.startColumn,\r\n                    letterIndex: key,\r\n                    word: '(' + word.number + ')',\r\n                    code: 'A' + count\r\n                };\r\n                // Calculate the letter position.\r\n                const position = this.calculatePosition(word, parseInt(key));\r\n                // Create rect element with these position.\r\n                const rectEl = this.createElementNSFrom(\r\n                    'rect',\r\n                    {\r\n                        ...position,\r\n                        width: cellWidth,\r\n                        height: cellHeight,\r\n                        'class': 'crossword-cell'\r\n                    }\r\n                );\r\n                // Create g element with the attributes.\r\n                let g = this.createElementNSFrom('g', {...customAttribute});\r\n                // Get exist ting rect element.\r\n                const existingRectElement = svg.querySelector(`rect.crossword-cell[x='${position.x}'][y='${position.y}']`);\r\n                // Create text element to hold the letter.\r\n                const textEl = this.createElementNSFrom(\r\n                    'text',\r\n                    {\r\n                        x: position.x + 11,\r\n                        y: position.y + 21,\r\n                        'class': 'crossword-cell-text'\r\n                    }\r\n                );\r\n                // Check if cell is not drawn.\r\n                if (!existingRectElement) {\r\n                    // Create cell.\r\n                    g.append(rectEl);\r\n                    // If it's the first cell of word.\r\n                    // Draw word number.\r\n                    if (parseInt(key) === 0) {\r\n                        g = this.appendCellNumber(g, position, word.number);\r\n                    }\r\n                    g.append(textEl);\r\n                    // Add event for cell.\r\n                    this.addEventForG(g);\r\n                    count++;\r\n                    svg.append(g);\r\n                } else {\r\n                    let existingNumberElement = existingRectElement.closest('g').querySelector('text.crossword-cell-number');\r\n                    let currentWord = existingRectElement.closest('g').getAttribute('word');\r\n                    let g;\r\n                    existingRectElement.closest('g').setAttributeNS(null, 'word', currentWord + '(' + word.number + ')');\r\n                    if (parseInt(key) !== 0) {\r\n                        continue;\r\n                    }\r\n                    if (existingNumberElement) {\r\n                        // Append word number, if this cell is existed another one.\r\n                        existingNumberElement.append(', ' + word.number);\r\n                    } else {\r\n                        // Create new word number.\r\n                        g = existingRectElement.closest('g');\r\n                        this.appendCellNumber(g, position, word.number);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return svg;\r\n    }\r\n\r\n    /**\r\n     * Create word number for the cell.\r\n     *\r\n     * @param {Element} g The g element.\r\n     * @param {Object} position The coordinates of letter.\r\n     * @param {Number} wordNumber The word number.\r\n     *\r\n     * @return {Element} The g element.\r\n     */\r\n    appendCellNumber(g, position, wordNumber) {\r\n        // Update position.\r\n        const x = position.x + 1;\r\n        const y = position.y + 9;\r\n        let textNumber = this.createElementNSFrom(\r\n            'text',\r\n            {\r\n                x,\r\n                y,\r\n                'class': 'crossword-cell-number'\r\n            }\r\n        );\r\n        textNumber.append(wordNumber);\r\n        g.append(textNumber);\r\n        return g;\r\n    }\r\n\r\n    /**\r\n     * Add event to the g element.\r\n     *\r\n     * @param {Element} g The g element.\r\n     */\r\n    addEventForG(g) {\r\n        const {readonly} = this.options;\r\n        if (readonly) {\r\n            return;\r\n        }\r\n        // Handle event click.\r\n        g.addEventListener('click', (e) => {\r\n            const inputWrapperEl = this.options.crosswordEl.querySelector('.crossword-hidden-input-wrapper');\r\n            const inputEl = inputWrapperEl.querySelector('input');\r\n            let element = e.target;\r\n            // Make sure select g.\r\n            if (element.tagName !== 'g') {\r\n                element = element.closest('g');\r\n            }\r\n            this.handleWordSelect(element);\r\n            inputEl.setAttributeNS(null, 'code', element.getAttributeNS(null, 'code'));\r\n            inputEl.value = '';\r\n            this.updatePositionForCellInput(element.querySelector('rect'));\r\n            inputEl.focus();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handle action when click on cell.\r\n     *\r\n     * @param {Element} gEl The g element.\r\n     */\r\n    handleWordSelect(gEl) {\r\n        const currentCell = gEl.getAttributeNS(null, 'code');\r\n        let words = gEl.getAttributeNS(null, 'word');\r\n        let focus = -1;\r\n        let {coordinates, wordNumber} = this.options;\r\n\r\n        // Detect word number.\r\n        words = words.match(/(\\d+)/g);\r\n\r\n        // Detect word number based on event click.\r\n        // The focus variable is the new word number.\r\n        if (currentCell === coordinates) {\r\n            const indexCell = words.indexOf(wordNumber);\r\n            if (words[indexCell + 1] !== undefined) {\r\n                focus = words[indexCell + 1];\r\n            } else {\r\n                focus = words[0];\r\n            }\r\n        } else {\r\n            // Update new coordinates.\r\n            this.options.coordinates = currentCell;\r\n            if (wordNumber < 0) {\r\n                this.options.wordNumber = words[0];\r\n            }\r\n            if (words.includes(wordNumber)) {\r\n                focus = wordNumber;\r\n            } else {\r\n                focus = words[0];\r\n            }\r\n        }\r\n        // Update word number.\r\n        this.options.wordNumber = focus;\r\n        const word = this.options.words.find(o => o.number === parseInt(focus));\r\n        if (!word) {\r\n            return;\r\n        }\r\n        // Sorting and Updating letter index.\r\n        this.updateLetterIndexForCells(word);\r\n        // Toggle highlight and focused.\r\n        this.toggleHighlight(word, gEl);\r\n        // Focus the clue.\r\n        this.focusClue();\r\n        // Update sticky clue for mobile version.\r\n        this.setStickyClue();\r\n    }\r\n\r\n    /**\r\n     * Set size and position for cell input.\r\n     *\r\n     * @param {Element} [rectEl=null] Rect element.\r\n     */\r\n    updatePositionForCellInput(rectEl = null) {\r\n        if (rectEl === null) {\r\n            rectEl = this.options.crosswordEl.querySelector('rect.crossword-cell-focussed');\r\n        }\r\n        if (rectEl) {\r\n            const rect = rectEl.getBoundingClientRect();\r\n            const parentEl = this.options.crosswordEl.querySelector('.crossword-grid').getBoundingClientRect();\r\n            const inputWrapperEl = this.options.crosswordEl.querySelector('.crossword-hidden-input-wrapper');\r\n            let top = rect.top - parentEl.top;\r\n            if (top < 1) {\r\n                top = 1;\r\n            }\r\n            inputWrapperEl.style.cssText = `\r\n                display: block; top: ${top}px;\r\n                left: ${rect.left - parentEl.left}px;\r\n                width: ${rect.width}px;\r\n                height: ${rect.height}px\r\n            `;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add event to word input element.\r\n     *\r\n     * @param {Element} inputEl The input element.\r\n     */\r\n    addEventForWordInput(inputEl) {\r\n        const {readonly} = this.options;\r\n        if (readonly) {\r\n            return;\r\n        }\r\n        inputEl.addEventListener('keypress', (e) => {\r\n            e.preventDefault();\r\n            const {wordNumber} = this.options;\r\n            const inputEl = e.target;\r\n            const code = inputEl.getAttributeNS(null, 'code');\r\n            let value = e.key.toUpperCase();\r\n            if (this.replaceText(e.key) === '') {\r\n                return false;\r\n            }\r\n            // Filter value.\r\n            if (code) {\r\n                const textEl = this.options.crosswordEl.querySelector(`g[code='${code}'] text.crossword-cell-text`);\r\n                if (!textEl) {\r\n                    return false;\r\n                }\r\n                textEl.innerHTML = value;\r\n                const letterIndex = parseInt(textEl.closest('g').getAttributeNS(null, 'letterIndex'));\r\n                const nextCellEl = this.options.crosswordEl.querySelector(\r\n                    `g[word*='(${wordNumber})'][letterIndex='${letterIndex + 1}']`\r\n                );\r\n                // Interact with clue.\r\n                this.bindDataToClueInput(textEl.closest('g'), e.key);\r\n                if (nextCellEl) {\r\n                    nextCellEl.dispatchEvent(new Event('click'));\r\n                }\r\n            }\r\n            return true;\r\n        });\r\n\r\n        inputEl.addEventListener('keyup', (event) => {\r\n            event.preventDefault();\r\n            const {wordNumber, cellWidth, cellHeight} = this.options;\r\n            const {key, target} = event;\r\n            const code = target.getAttributeNS(null, 'code');\r\n            const gEl = this.options.crosswordEl.querySelector(`g[code='${code}']`);\r\n            const letterIndex = parseInt(gEl.getAttributeNS(null, 'letterIndex'));\r\n            const previousCell = this.options.crosswordEl.querySelector(\r\n                `g[word*='(${wordNumber})'][letterIndex='${letterIndex - 1}']`\r\n            );\r\n            const textEl = gEl.querySelector('text.crossword-cell-text');\r\n            let x = parseInt(gEl.querySelector('rect').getAttributeNS(null, 'x'));\r\n            let y = parseInt(gEl.querySelector('rect').getAttributeNS(null, 'y'));\r\n            if (key === this.DELETE || key === this.BACKSPACE) {\r\n                if (textEl.innerHTML === '') {\r\n                    if (previousCell) {\r\n                        previousCell.dispatchEvent(new Event('click'));\r\n                    }\r\n                } else {\r\n                    textEl.innerHTML = '';\r\n                    this.bindDataToClueInput(gEl, '_');\r\n                }\r\n            }\r\n            if ([this.ARROW_UP, this.ARROW_DOWN, this.ARROW_LEFT, this.ARROW_RIGHT].includes(key)) {\r\n                if (key === this.ARROW_UP) {\r\n                    y -= (cellHeight + 1);\r\n                }\r\n                if (key === this.ARROW_DOWN) {\r\n                    y += (cellHeight + 1);\r\n                }\r\n                if (key === this.ARROW_LEFT) {\r\n                    x -= (cellWidth + 1);\r\n                }\r\n                if (key === this.ARROW_RIGHT) {\r\n                    x += (cellWidth + 1);\r\n                }\r\n                const nextCell = this.options.crosswordEl.querySelector(`g rect[x='${x}'][y='${y}']`);\r\n                if (nextCell) {\r\n                    nextCell.closest('g').dispatchEvent(new Event('click'));\r\n                }\r\n            }\r\n        });\r\n\r\n        inputEl.addEventListener('click', (e) => {\r\n            const inputEl = e.target;\r\n            const code = inputEl.getAttributeNS(null, 'code');\r\n            const gEl = this.options.crosswordEl.querySelector(`g[code='${code}']`);\r\n            this.handleWordSelect(gEl);\r\n        });\r\n\r\n        inputEl.addEventListener('keydown', (e) => {\r\n            let {key} = e;\r\n            key = key.toLowerCase();\r\n            if (e.ctrlKey) {\r\n                if (\r\n                    key === this.Z_KEY ||\r\n                    key === this.A_KEY\r\n                ) {\r\n                    e.preventDefault();\r\n                }\r\n            }\r\n\r\n            if (e.key === this.ENTER) {\r\n                e.preventDefault();\r\n            }\r\n        });\r\n\r\n        inputEl.addEventListener('paste', (e) => {\r\n            e.preventDefault();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Add event to resize the screen width.\r\n     */\r\n    addEventResizeScreen() {\r\n        window.addEventListener('resize', () => {\r\n            this.updatePositionForCellInput();\r\n        });\r\n    }\r\n}\r\n"],"names":["CrosswordGrid","CrosswordQuestion","constructor","options","buildBackgroundTable","colsNum","rowsNum","previewSetting","this","style","tableEl","document","createElement","className","backgroundColor","i","rowEl","j","squareEl","borderColor","color","classList","add","innerText","getColumnLabel","append","crosswordEl","innerHTML","outerHTML","addCell","words","length","row","startrow","column","startcolumn","answerLength","answer","realLength","allowLength","parseInt","invalidWord","clue","trim","isInvalidAnswer","orientation","number","querySelector","labelEl","label","_words$i2","no","spanEl","_words$i","letter","toUpperCase","contentEl","text","search","conflictColor","previewCrossword","buildCrossword","width","height","CrosswordClue","setUpClue","drawCrosswordSVG","syncDataForInit","addEventResizeScreen","svg","createElementNSFrom","viewBox","rectEl","x","y","createCrosswordBody","inputContainEl","createElementFrom","inputEl","type","maxlength","autocomplete","spellcheck","autocorrect","addEventForWordInput","attributes","element","createElementNS","key","setAttributeNS","setAttribute","cellWidth","cellHeight","count","word","customAttribute","startRow","startColumn","letterIndex","code","position","calculatePosition","g","existingRectElement","textEl","existingNumberElement","closest","currentWord","getAttribute","appendCellNumber","addEventForG","wordNumber","textNumber","readonly","addEventListener","e","target","tagName","handleWordSelect","getAttributeNS","value","updatePositionForCellInput","focus","gEl","currentCell","coordinates","match","indexCell","indexOf","undefined","includes","find","o","updateLetterIndexForCells","toggleHighlight","focusClue","setStickyClue","rect","getBoundingClientRect","parentEl","inputWrapperEl","top","cssText","left","preventDefault","replaceText","nextCellEl","bindDataToClueInput","dispatchEvent","Event","event","previousCell","DELETE","BACKSPACE","ARROW_UP","ARROW_DOWN","ARROW_LEFT","ARROW_RIGHT","nextCell","toLowerCase","ctrlKey","Z_KEY","A_KEY","ENTER","window"],"mappings":"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"}
>>>>>>> d168b46 (Crossword: overwrite letter issue in Clues area)
